#include "commandConsole.h"
#include "uart.h"



/* Dimensions the buffer into which input characters are placed. */
#define cmdMAX_INPUT_SIZE  512



/* DEL acts as a backspace. */
#define cmdASCII_DEL        ( 0x7F )


static const char * const pcNewLine = "\r\n";


//命令行欢迎
void command_console_init(void)
{
    printf("FreeRTOS command server.\r\n");
    printf("type 'help' to view a list of registered commands.\r\n");
 
}

//命令行解包  移植需要调用
void command_console_unpack(void)
{

    signed char cRxedChar;
    uint8_t ucInputIndex = 0;
    char pcOutputString[ cmdMAX_INPUT_SIZE ];
    static char cInputString[ cmdMAX_INPUT_SIZE ], cLastInputString[ cmdMAX_INPUT_SIZE ];
    BaseType_t xReturned;
    uint8_t len;
    uint8_t takeNum = 0;

    memset( pcOutputString, 0x00, cmdMAX_INPUT_SIZE );
    
    //移植要点 命令行输入数据长度
    len = queue_get_count(&queue_uart1_rx);
    
    if(len == 0)
    {
        return;
    }

    do 
    {
        //移植要点 命令行取输入数据
        queue_get(&queue_uart1_rx,(uint8_t *)&cRxedChar);
        takeNum++;
        
        /* Was it the end of the line? */
        if( cRxedChar == '\n' )
        {
            
            
            /* Just to space the output from the input. */

            
            
            /* See if the command is empty, indicating that the last command
            is to be executed again. */
            if( ucInputIndex == 0 )
            {
                /* Copy the last command back into the input string. */
                strcpy( cInputString, cLastInputString );
            }

            /* Pass the received command to the command interpreter.  The
            command interpreter is called repeatedly until it returns
            pdFALSE    (indicating there is no more output) as it might
            generate more than one string. */
            do
            {
                /* Get the next output string from the command interpreter. */
                xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );

                /* Write the generated string to the UART. */
                
                if(strlen( pcOutputString ))
                {
                    //移植要点 命令行数据发送
                    uart1_send(( uint8_t * ) pcOutputString, strlen( pcOutputString ));
                    
                    uart1_send(( uint8_t * ) pcNewLine, strlen( pcNewLine ));
                }                    

            } while( xReturned != pdFALSE );

            /* All the strings generated by the input command have been
            sent.  Clear the input string ready to receive the next command.
            Remember the command that was just processed first in case it is
            to be processed again. */
            strcpy( cLastInputString, cInputString );
            ucInputIndex = 0;
            memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );

        }
        else
        {
            if( cRxedChar == '\r' )
            {
                /* Ignore the character. */
            }
            else if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
            {
                /* Backspace was pressed.  Erase the last character in the
                string - if any. */
                if( ucInputIndex > 0 )
                {
                    ucInputIndex--;
                    cInputString[ ucInputIndex ] = '\0';
                }
            }
            else
            {
                /* A character was entered.  Add it to the string entered so
                far.  When a \n is entered the complete    string will be
                passed to the command interpreter. */
                if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
                {
                    if( ucInputIndex < cmdMAX_INPUT_SIZE )
                    {
                        cInputString[ ucInputIndex ] = cRxedChar;
                        ucInputIndex++;
                    }
                }
            }
        }
        
        
    }while(!(takeNum >= len));
    
        
}



